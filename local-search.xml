<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSES Sliding Window or</title>
    <link href="/cses-sliding-wiondow-or/"/>
    <url>/cses-sliding-wiondow-or/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cses.fi/problemset/task/3426">link</a></p><p>這題困擾我蠻久的，因為 <code>or</code> 運算不像 <code>xor</code> 或 <code>+</code> 具有反操作。<br>也就是不能像是 <strong>Sliding Window Xor</strong> <code>O(1)</code> 滑窗，但是如果拆位的話可能會 TLE。</p><p>因此，我們需要一個新的滑窗方法，把原本的陣列先拆成幾塊，然後再滑到某一塊非邊界的點的時候，其 Sliding Window or 就是上個邊界的 or 前墜 <code>or</code> 下個邊界的 or 後墜。</p><p>e.g.</p><p>原陣列 : 1 2 3 4 5 6 7 8 -&gt; 每三個一塊<br>前墜or : 1 3 3|4 5 7|7 15<br>後墜or : 3 3 3|7 7 6|15 8<br>求 [2,4] 的 or &#x3D; 到 2 的 後墜or <code>or</code> 的前墜or -&gt;3 <code>or</code> 4</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, m, a, b, c, x;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n+<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">pre</span><span class="hljs-params">(n+<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">suf</span><span class="hljs-params">(n+<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>    arr[<span class="hljs-number">1</span>]=x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) arr[i]=(a*arr[i<span class="hljs-number">-1</span>]+b)%c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>, j=n;i&lt;=n;i++, j--) &#123;    <span class="hljs-comment">//這邊要好好想</span><br>        <span class="hljs-keyword">if</span>(j%m==<span class="hljs-number">0</span>) suf[j]=arr[j];<br>        <span class="hljs-keyword">else</span> suf[j]=suf[j+<span class="hljs-number">1</span>]|arr[j];<br>        <span class="hljs-keyword">if</span>((i<span class="hljs-number">-1</span>)%m==<span class="hljs-number">0</span>) pre[i]=arr[i];<br>        <span class="hljs-keyword">else</span> pre[i]=pre[i<span class="hljs-number">-1</span>]|arr[i];<br>    &#125;<br>    <span class="hljs-type">int</span> now=suf[<span class="hljs-number">1</span>], temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>, r=m+<span class="hljs-number">1</span>;r&lt;=n;l++, r++) &#123;<br>        <span class="hljs-keyword">if</span>(l%m==<span class="hljs-number">1</span>) temp=suf[l];<br>        <span class="hljs-keyword">else</span> temp=suf[l]|pre[r];<br>        now^=temp;<br>    &#125;<br>    cout&lt;&lt;now;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
      <tag>cses</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025IONC心得</title>
    <link href="/2025IONC/"/>
    <url>/2025IONC/</url>
    
    <content type="html"><![CDATA[<p>今年是第二次去。</p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><h2 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h2><p>去年選火車站，等了快一個小時，還沒吃午餐。<br>今年選自己去，吃了麵框框，還是覺得很好吃。</p><p>Day 1 是教基礎技巧(語法)，然後打趣味賽，但我實在不會閱讀測驗 : &lt;。</p><p><a href="https://ioncamp-internal.github.io/2025_scoreboard/day1/ranking/">DAY1版</a> RK15</p><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><p>Day 1 是教資結&amp;圖論，然後個人賽。</p><p>今年的資結還是很難，還是聽不懂，會的只有之前就會的。<br>但是圖論倒是吸收了超級多，非常開心。</p><p><a href="https://ioncamp-internal.github.io/2025_scoreboard/day2/ranking/">DAY2版</a> RK3<br>原本pD是最後才要拿滿，想給 TLE 驚喜，但是做爛了。<br>還是覺得自己跟暴力人差距好大。</p><h2 id="DAY-3-5"><a href="#DAY-3-5" class="headerlink" title="DAY 3~5"></a>DAY 3~5</h2><p>都是團體賽，我跟 TLE &amp;&amp; 草貓一組，三天RK1，最後一天斷網。</p><p>感覺都打得還不錯。</p><h2 id="FINAL"><a href="#FINAL" class="headerlink" title="FINAL"></a>FINAL</h2><p>這幾天其實還蠻為了升學焦慮了，令我印象最深刻的是林鼎陽學長，他人很好，個性率真，原本在問 Temmie 特選的事，後來變成跟他聊。 獲益良多。<br>還認識了暴力人，會了如何處理所有的Sliding window。<br>他真的好強。<br>最後經驗分享的時候也獲得許多跟特選與競賽程式有關的知識。</p>]]></content>
    
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
      <tag>營隊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025資芽心得</title>
    <link href="/2025%E8%B3%87%E8%8A%BD/"/>
    <url>/2025%E8%B3%87%E8%8A%BD/</url>
    
    <content type="html"><![CDATA[<p>心得來的有點晚 : &lt;</p><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>去年開始打競程鰻想跟 kzzz 一起去資芽的，但是後來想說算了，今年覺得禮拜六都沒事做就去了。</p><p>先說結論，自己蠻後悔的，以為自己拿不到優結，二階考就考的不是非常認真，但自己就只有二階考沒過。<br>我上的是南區的資芽，今年的講師是 布丁+colten，但是 colten 很忙，所以大部分是 布丁上課。由於第一階段的東西我基本上都學過了所以跳過，今年的第二階段的上課內容是投票決定的，我很喜歡這個投票結果，講了一堆我不熟或是我不想要碰的東西，學了很多新東西，含金量很高，價格相較於其他類似性質的也是非常便宜了。</p><p>這是我的怪目標 : 每次見到 colten 都跟他合照。—直到目前都成功</p><p>這是我的證書</p><iframe   src="https://docs.google.com/viewer?url=https://raw.githubusercontent.com/FliGhtzzz/PICTURE-online/f919059218cb358c91ee0374a88031cb43749851/資訊之芽證書.pdf&embedded=true"   width="700"   height="1000"   style="border:none;"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>連通分量整理</title>
    <link href="/%E9%80%A3%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <url>/%E9%80%A3%E9%80%9A%E5%88%86%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>[<a href="https://hackmd.io/@FliGhtzzsz/HkNJPBmwxx">Hackmd-link</a>]</p><p>哪裡寫得不好請用 discord dm 我。</p><p>練習題 : <a href="https://judge.yosupo.jp/">https://judge.yosupo.jp/</a> 的 gragh 中的點雙和邊雙。</p><h1 id="Connected-Component-連通分量"><a href="#Connected-Component-連通分量" class="headerlink" title="Connected Component (連通分量)"></a>Connected Component (連通分量)</h1><h2 id="DFS-Tree"><a href="#DFS-Tree" class="headerlink" title="DFS-Tree"></a>DFS-Tree</h2><h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><blockquote><p>在 DFS 的過程中，紀錄走訪的節點與邊，形成一棵 <strong>DFS-Tree</strong>。</p></blockquote><h4 id="有關邊的分類"><a href="#有關邊的分類" class="headerlink" title="有關邊的分類"></a>有關邊的分類</h4><p>Tree Edge  : DFS 過程中實際走訪所形成的邊</p><table><thead><tr><th>Back Edge</th><th>Forward Edge</th><th>Cross Edge</th></tr></thead><tbody><tr><td>指向 DFS 樹中祖先節點的邊</td><td>指向已拜訪過的子孫節點（非直接子節點）的邊</td><td>指向其他子樹或已完成探索區域的邊</td></tr></tbody></table><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 1"></a>定理 1</h3><p><strong>對於無向連通圖</strong> $G&#x3D;(V,E)$，其 DFS-Tree 中<strong>只會出現 Tree Edge 與 Back Edge</strong>。</p><blockquote><p><strong>證明</strong>：<br>假設 DFS-Tree 中出現 Cross Edge，則必須存在三個節點 $a,b,c$，使得 $a$ 是 $b,c$ 的祖先，且 $b,c$ 位於不同子樹，並且 $b,c$ 之間有一條邊（這條邊才會被歸類為 Cross Edge）。然而在 DFS 的過程中，當我們從 $a$ 拜訪 $b$ 時，由於 $b,c$ 之間存在邊，DFS 一定會從 $b$ 走到 $c$，使得 $c$ 成為 $b$ 的子孫。如此一來，該邊就會成為 Tree Edge 或 Back Edge，而非 Cross Edge。這與假設矛盾，因此無向連通圖中不會出現 Cross Edge（Forward Edge 同理）。</p></blockquote><hr><h2 id="AP-與-Bridge"><a href="#AP-與-Bridge" class="headerlink" title="AP 與 Bridge"></a>AP 與 Bridge</h2><h3 id="定義-1"><a href="#定義-1" class="headerlink" title="定義"></a>定義</h3><table><thead><tr><th>AP (Articulation Point, 割點)</th><th>Bridge (橋)</th></tr></thead><tbody><tr><td>從連通圖中移除此節點後，圖變得不連通</td><td>從連通圖中移除此邊後，圖變得不連通</td></tr></tbody></table><ul><li>$D(v)$：節點 $v$ 在 DFS 過程中的時間戳（&#x3D; DFS 深度），定義根節點 $D(root)&#x3D;0$。</li><li>$L(v)$：從節點 $v$ 與其子樹出發，<strong>最多透過一條 Back Edge</strong> 可以到達的節點的最小 DFS 深度（即 <strong>low-link value</strong>）。</li></ul><p><strong>註</strong> : 不難發現 $\forall$back edge $\not \in$ Bridge。</p><h3 id="定理-1-1"><a href="#定理-1-1" class="headerlink" title="定理 1"></a>定理 1</h3><p><strong>若 DFS-Tree 的根節點 $r$ 有至少兩個子樹，則 $r$ 是 AP。</strong></p><blockquote><p><strong>證明</strong>：<br>若 $deg(r) &#x3D; 1$，刪除 $r$ 之後，DFS Tree 下方的子節點可以直接作為新根，圖仍連通。<br>但若 $deg(r) \ge 2$，刪除 $r$ 後，其下方的多個子樹將彼此斷開，形成多個連通分量，因此 $r$ 必為 AP。</p></blockquote><hr><h3 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 2"></a>定理 2</h3><p><strong>對於 DFS-Tree 上的非根節點 $v$：</strong></p><p>$$<br> v \text{ 是 AP} \iff \exists w \text{ 是 } v \text{ 的子節點，使得 } L(w) \ge D(v)<br>$$</p><blockquote><p><strong>證明</strong>：<br>(⇒) 若 $v$ 是割點，則刪掉 $v$ 後，至少有一個子樹（以子節點 $w$ 為根）與圖的其他部分斷開。若該子樹存在 back edge 連回 $v$ 的祖先（即 $L(w) &lt; D(v)$），即使刪除 $v$ 也能保持連通，與 $v$ 是割點的假設矛盾。因此必有子節點 $w$ 使 $L(w) \ge D(v)$。</p><p>(⇐) 反之，若存在 $w$ 使 $L(w) \ge D(v)$，說明從 $w$ 的子樹中，沒有 back edge 可以連到 $v$ 的祖先。刪掉 $v$ 後，$w$ 的子樹就無法與圖上層連通，因此 $v$ 必為割點。</p></blockquote><hr><h3 id="定理-3"><a href="#定理-3" class="headerlink" title="定理 3"></a>定理 3</h3><p>$\text{let v DFS-Tree上一點}, (v, w) 為 bridge\iff \exists w \text{ 是 } v \text{ 的子節點，使得 } L(w)&gt;D(v)$</p><blockquote><p><strong>證明</strong>：<br>同上，因為沒有從 $w$ 的及其子樹出發的 back edge 可以連到 深度$&lt;D(v)$的點，因此若邊 $(v, w)$ 是 bridge。</p></blockquote><h3 id="線性時間求圖上-AP-Bridge-的方法"><a href="#線性時間求圖上-AP-Bridge-的方法" class="headerlink" title="線性時間求圖上 AP&#x2F;Bridge 的方法"></a>線性時間求圖上 AP&#x2F;Bridge 的方法</h3><p>結合上述定理可得此程式，看你需要對 AP&#x2F;Bridge 來修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> par)</span> </span>&#123;<br>    dfn[now]=low[now]=ts++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:adj[now]) &#123;<br>        <span class="hljs-keyword">if</span>(v==par) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//這邊如果是有邊權的情況再調整</span><br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, now);<br>            low[now]=<span class="hljs-built_in">min</span>(low[now], low[v]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[now]=<span class="hljs-built_in">min</span>(low[now], dfn[v]);<br>    &#125;<br>            <span class="hljs-comment">// if(now != root &amp;&amp; low[nb] &gt;= dfn[now]) -&gt; AP</span><br>            <span class="hljs-comment">// if(low[nb] &gt; dfn[now]) -&gt; bridge</span><br>    <span class="hljs-comment">// if(now == root &amp;&amp; child &gt;= 2) -&gt; AP</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bridge-Connected-Component"><a href="#Bridge-Connected-Component" class="headerlink" title="Bridge Connected Component"></a>Bridge Connected Component</h2><h3 id="定義-2"><a href="#定義-2" class="headerlink" title="定義"></a>定義</h3><p>將一張圖 $G(V, E)$，的所有的橋給移除，就會變成橋連通分量(又稱邊雙)。</p><ul><li>橋連通分量 &#x3D; Bridge Connected Component 簡稱 BCC。</li><li>性質 : 橋連通分量上的任何一條邊被移除都不會影響橋的連通性，且將原本的橋給放回去後，會變成一棵樹。</li></ul><h3 id="定理-1-2"><a href="#定理-1-2" class="headerlink" title="定理 1"></a>定理 1</h3><p><strong>若</strong>$D(w)&#x3D;L(w)$，則 $w$ 是橋連通分量上的一端點。</p><blockquote><p> <strong>證明</strong>：<br>DFS 時，若某個點 沒辦法透過 Back Edge 回到祖先 (更淺的節點)，那麼 DFS Tree 上就會在這個點「切斷」。</p></blockquote><p>實作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> par)</span> </span>&#123;<br>    dfn[now]=low[now]=ts++;<br>    stk.<span class="hljs-built_in">push</span>(now);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:adj[now]) &#123;<br>        <span class="hljs-keyword">if</span>(v==par) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">//這邊如果是有邊權的情況再調整</span><br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            <span class="hljs-built_in">dfs</span>(v, now);<br>            low[now]=<span class="hljs-built_in">min</span>(low[now], low[v]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[now]=<span class="hljs-built_in">min</span>(low[now], dfn[v]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(low[now]==dfn[now]) &#123; <span class="hljs-comment">//註 1</span><br>        <span class="hljs-type">int</span> x;<br>        bcccnt++;<br>        <span class="hljs-keyword">do</span> &#123;<br>            x=stk.<span class="hljs-built_in">top</span>();<br>            bcc[x]=bcccnt;<br>            stk.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">while</span>(x!=now);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>註 1</p><blockquote><p>遍歷 $v$ 的子樹後，若 $v$ 的子樹沒辦法透過 Back Edge 回到 $v$ 的祖先，則 $v$ 為橋連通分量上的一端點，若 $v$ 的子樹中存在其他橋連通分量，則分量對在遞迴到它時，完成它在 stk 的移除，使 $v$ 的橋連通分量不包含它。 </p></blockquote></li><li><p>註 2</p></li></ul><p>這是需要圖無重邊才能使用。若圖有重邊可能形成 $G$ 有兩個點兩條無向邊。使圖不存在 Bridge。</p><p>為了解決重邊，核心想法是在 DFS 過程中紀錄哪一條邊是橋。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//0-based 重邊</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EdgeBCC</span>&#123;<br>    <span class="hljs-type">int</span> n, m, dep, sz;<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; G;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; bcc;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dfn, low, stk, isBridge, bccId;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edge, bridge;<br><br>    <span class="hljs-built_in">EdgeBCC</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">m</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">sz</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">dfn</span>(n), <span class="hljs-built_in">low</span>(n), <span class="hljs-built_in">G</span>(n), <span class="hljs-built_in">bcc</span>(n), <span class="hljs-built_in">bccId</span>(n) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        edge.<span class="hljs-built_in">push_back</span>(&#123;u, v&#125;);<br>        G[u].<span class="hljs-built_in">push_back</span>(&#123;v, m&#125;);<br>        G[v].<span class="hljs-built_in">push_back</span>(&#123;u, m++&#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>        dfn[now] = low[now] = ++dep;<br>        stk.<span class="hljs-built_in">push_back</span>(now);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, id] : G[now])&#123;<br>            <span class="hljs-keyword">if</span> (!dfn[x])&#123;<br>                <span class="hljs-built_in">dfs</span>(x, id);<br>                low[now] = <span class="hljs-built_in">min</span>(low[now], low[x]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id!=pre)&#123;<br>                low[now] = <span class="hljs-built_in">min</span>(low[now], dfn[x]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (low[now]==dfn[now])&#123;<br>            <span class="hljs-keyword">if</span> (pre!=<span class="hljs-number">-1</span>) isBridge[pre] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> u;<br>            <span class="hljs-keyword">do</span>&#123;<br>                u = stk.<span class="hljs-built_in">back</span>();<br>                stk.<span class="hljs-built_in">pop_back</span>();<br>                bcc[sz].<span class="hljs-built_in">push_back</span>(u);<br>                bccId[u] = sz;<br>            &#125; <span class="hljs-keyword">while</span> (u!=now);<br>            sz++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_bcc</span><span class="hljs-params">()</span> </span>&#123;<br>        isBridge.<span class="hljs-built_in">assign</span>(m, <span class="hljs-number">0</span>);<br>        dep = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;n ; i++)&#123;<br>            <span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span> ; i&lt;m ; i++)&#123;<br>            <span class="hljs-keyword">if</span> (isBridge[i])&#123;<br>                bridge.<span class="hljs-built_in">push_back</span>(&#123;edge[i].first , edge[i].second&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Biconnected-Component"><a href="#Biconnected-Component" class="headerlink" title="Biconnected Component"></a>Biconnected Component</h2><h3 id="定義-3"><a href="#定義-3" class="headerlink" title="定義"></a>定義</h3><ul><li>雙連通分量(點雙) &#x3D;  Biconnected Component 也是簡稱 BCC。</li><li>性質 : 若一張圖為雙連通則該圖不存在AP。</li></ul><p>我們稱圖 $G&#x3D;(V, E)$ 的雙連通分量 $S\subseteq V$ 滿足以下條件 :</p><ol><li>$S$ 是雙連通的。</li><li>無法再加一個點就無法滿足 1.</li></ol><p>接著以下圖舉例。</p><p><img src="https://hackmd.io/_uploads/rkwgsqNPgl.png" alt="image"></p><p>可以發現可以把此圖改成下面兩種的雙連通分量。</p><p><img src="https://hackmd.io/_uploads/SkpWjcNDge.png" alt="image"></p><p><img src="https://hackmd.io/_uploads/rys4j5Nvlx.png" alt="image"></p><p>不難發現，如果一個點 $v$ 可以同時可能在兩個雙連通分量，那這個點就會是 $G$ 的 $AP$。</p><p>從上面我們知道 AP 即為連接不同雙連通分量的「端點」，<br>因此也能用類似的方式來求出雙連通分量。</p><p>不覺得這個跟判斷橋連通很像嗎?<br>所以我們按照橋連通來實作吧。</p><p>但重邊與否應該不影響這邊的實作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BCC</span> &#123;<br>    <span class="hljs-type">int</span> n, timer;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G;<br>    vector&lt;<span class="hljs-type">int</span>&gt; dfn, low;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; bcc;<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; stk;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; inBCC;    <span class="hljs-comment">// 標記哪些點出現在 BCC 中</span><br>    vector&lt;<span class="hljs-type">char</span>&gt; vis;      <span class="hljs-comment">// 用於 extractBCC，避免 sort/unique</span><br><br>    <span class="hljs-built_in">BCC</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">timer</span>(<span class="hljs-number">0</span>) &#123;<br>        G.<span class="hljs-built_in">assign</span>(n, &#123;&#125;);<br>        dfn.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>        low.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>        inBCC.<span class="hljs-built_in">assign</span>(n, <span class="hljs-literal">false</span>);<br>        vis.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        G[u].<span class="hljs-built_in">push_back</span>(v);<br>        G[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> parent)</span> </span>&#123;<br>        dfn[u] = low[u] = ++timer;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) &#123;<br>            <span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br>                stk.<span class="hljs-built_in">emplace</span>(u, v);      <span class="hljs-comment">// 樹邊</span><br>                <span class="hljs-built_in">dfs</span>(v, u);<br>                low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br><br>                <span class="hljs-keyword">if</span> (low[v] &gt;= dfn[u]) &#123; <span class="hljs-comment">// u 是關節點</span><br>                    <span class="hljs-built_in">extractBCC</span>(u, v);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v != parent &amp;&amp; dfn[v] &lt; dfn[u]) &#123;<br>                stk.<span class="hljs-built_in">emplace</span>(u, v);      <span class="hljs-comment">// 回邊</span><br>                low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extractBCC</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; comp;<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [x, y] = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!vis[x]) &#123; vis[x] = <span class="hljs-literal">true</span>; comp.<span class="hljs-built_in">push_back</span>(x); &#125;<br>            <span class="hljs-keyword">if</span> (!vis[y]) &#123; vis[y] = <span class="hljs-literal">true</span>; comp.<span class="hljs-built_in">push_back</span>(y); &#125;<br>            <span class="hljs-keyword">if</span> (x == u &amp;&amp; y == v) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!comp.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : comp) &#123;<br>                inBCC[node] = <span class="hljs-literal">true</span>;<br>                vis[node] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// reset for下一次 BCC 使用</span><br>            &#125;<br>            bcc.<span class="hljs-built_in">push_back</span>(comp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_bcc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!dfn[i]) &#123;<br>                <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>);<br>                <span class="hljs-keyword">if</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; comp;<br>                    <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">auto</span> [x, y] = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">if</span> (!vis[x]) &#123; vis[x] = <span class="hljs-literal">true</span>; comp.<span class="hljs-built_in">push_back</span>(x); &#125;<br>                        <span class="hljs-keyword">if</span> (!vis[y]) &#123; vis[y] = <span class="hljs-literal">true</span>; comp.<span class="hljs-built_in">push_back</span>(y); &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!comp.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> node : comp) &#123;<br>                            inBCC[node] = <span class="hljs-literal">true</span>;<br>                            vis[node] = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        bcc.<span class="hljs-built_in">push_back</span>(comp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 單獨出現的點（沒在任何 BCC 中）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!inBCC[i]) &#123;<br>                bcc.<span class="hljs-built_in">push_back</span>(&#123;i&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>資訊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025學科校內賽心得</title>
    <link href="/2025%E6%A0%A1%E5%85%A7%E8%B3%BD%E5%BF%83%E5%BE%97/"/>
    <url>/2025%E6%A0%A1%E5%85%A7%E8%B3%BD%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<p>這次的校內賽是由明達學長出題的，總共六題，難度非常的高。</p><h2 id="pA-華生的資料注入"><a href="#pA-華生的資料注入" class="headerlink" title="pA 華生的資料注入"></a>pA <strong>華生的資料注入</strong></h2><p>我覺得這題可能有問題因此我選擇打好題敘。</p><h3 id="題文"><a href="#題文" class="headerlink" title="題文"></a>題文</h3><blockquote><p>華生是一名時間旅者。為了避免未來L公司的人工智能「天眼」(SkyEyes)失控導致世界毀滅，她穿越回天眼仍在訓練階段的現在。今日，華生已經成功打入L公司內部，成為一名L公司高層。<br>已知要阻止天眼失控，其中一個條件是需在訓練階段加入夠多符合某些標準的特殊資料。華生自己還要處理太多其他導致天眼失控的因素，於是將產生這些資料交給自己的得意助手－－也就是你。<br>華生對於每筆資料會以 $S,m,M$ 紀錄，代表該筆資料應該符合以下所有條件：</p><ul><li>總和等於 $S$。</li><li>最小值等於 $m$。</li><li>最大值等於 $M$。</li></ul><h4 id="輸入"><a href="#輸入" class="headerlink" title="輸入"></a>輸入</h4><p>輸入第一行包含一個整數 $t$。<br>接下來t行，每行包含整數 $S,m,M$。<br>$1\le t\le1000$<br>$0\le m \le M\le100$</p><h4 id="輸出"><a href="#輸出" class="headerlink" title="輸出"></a>輸出</h4><p>輸出 $t$ 行，每行可包含最多 100 個整數，代表符合對應條件的資料。如果有多種符合條件的解，輸出任一個解即可。已知必有解。</p><h4 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a>e.g.</h4><p>&#x2F;&#x2F;input<br>2<br>15 1 5<br>16 0 9<br>&#x2F;&#x2F;output<br>5 3 4 1 2<br>0 1 3 3 9</p></blockquote><p>我在這題的實作上有許多問題，像是我對範測中輸出 “1 5 4 4 1\n0 1 3 3 9\n” 收到$WA$。<br>但是輸出 “5 3 4 1 2\n0 1 3 3 9\n” 卻是$AC$。<br>非常的玄，我嚴重懷疑 spj 有問題，但 <strong>kzzz</strong> 神奇的AC了。</p><h2 id="pB-彭羅的宇宙棋盤"><a href="#pB-彭羅的宇宙棋盤" class="headerlink" title="pB 彭羅的宇宙棋盤"></a>pB <strong>彭羅的宇宙棋盤</strong></h2><h3 id="題文-1"><a href="#題文-1" class="headerlink" title="題文"></a>題文</h3><blockquote><p>給一個 $n\times m(1\le n, m \le 10^5)$ 的圖，在圖上一次只能往右或往下移動一個，圖上有 $k(0\le k \le max(mn, 2000)) $個無法通過的點，問從 $(0, 0)$ 出發到 $(n-1, m-1)$ 的方法數 $%10^9+7$。<br>subtask 1 30% $1\le n, m \le 2000$。<br>subtask 2 70% 無限制。</p></blockquote><p>這題我的想法是 DP 蓋圖拿子題，有試使用 C++ vector 蓋 $nm$ 的圖，但一樣只有 $30%$，由於是用 0j，有人用 python 蓋 $nm$ 拿了 80%，相當破防。<br>賽後發現可以用排容處理 $k$，而且好像是 CSES addional-problems 的題目。</p><h2 id="pC-貝兒的分類器"><a href="#pC-貝兒的分類器" class="headerlink" title="pC 貝兒的分類器"></a>pC <strong>貝兒的分類器</strong></h2><p>閱讀測驗題，我沒看(0%)，kzzz說超裸，讀完就有。</p><h2 id="pD-約瑟夫的遞增輪盤"><a href="#pD-約瑟夫的遞增輪盤" class="headerlink" title="pD 約瑟夫的遞增輪盤"></a>pD <strong>約瑟夫的遞增輪盤</strong></h2><p>約瑟夫問題，$N$ 個人，數到 $k$ 的人淘汰，$k$ 會動態調整: $k&#x3D;1+ai+b(1\le a, b\le2\times 10^5,i為淘汰的人數)$，求最後存活的人的編號。</p><blockquote><p>subtask 1 10% $a&#x3D;0$<br>subtask 2 20% $N\le 2000$<br>subtask 3 10% 無限制。</p></blockquote><p>這題 <strong>kzzz</strong> 直接砸pbds order set。我只有拿子題20%。</p><h2 id="pE-泰拉的地形改造"><a href="#pE-泰拉的地形改造" class="headerlink" title="pE 泰拉的地形改造"></a>pE <strong>泰拉的地形改造</strong></h2><p>$N\times M(1\le N, M\le 200)$的表格，只會有3種字符 0,+,-，每次可以選一行或列+&#x2F;-1，讓最後0的位置是0，+的位置&gt;0，-的位置&lt;0，求最小操作次數，無解輸出-1。</p><blockquote><p>subtask 1 30% $N, M\le4$<br>subtask 2 70% 無限制。</p></blockquote><p>相當難的題目，但我猜是 DP 或是神奇的枚舉剪枝，但我不會，好像輸出-1拿了20%。</p><h2 id="pF-桑義的完美陣列"><a href="#pF-桑義的完美陣列" class="headerlink" title="pF 桑義的完美陣列"></a>pF <strong>桑義的完美陣列</strong></h2><p>給一個陣列 $A$ 有 $N(1\le N\le 2\times 10^5)$ 個元素$\forall 1\le i \le N(1\le a_i\le10^9)$，，求最少要刪除幾個元素使甚下的每個元素都互質。<br>我在賽中就想到了蓋到$2 \times 10^5$ 的質數前綴和，但記憶體卡很死，最後有成功使它到$2 \times 10^5$，但是還是$WA$ 90%。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我很不滿意我這次的成績(160%)，就算加上 pA 和 pC，也只有360%，嚴重小於 kzzz 的 470%。</p>]]></content>
    
    
    <categories>
      
      <category>高中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
      <tag>競賽</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精誠高中讀書會</title>
    <link href="/%E7%B2%BE%E8%AA%A0%E9%AB%98%E4%B8%AD%E8%AE%80%E6%9B%B8%E6%9C%83%E8%AC%9B%E5%B8%AB/"/>
    <url>/%E7%B2%BE%E8%AA%A0%E9%AB%98%E4%B8%AD%E8%AE%80%E6%9B%B8%E6%9C%83%E8%AC%9B%E5%B8%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>精誠高中可以說是一間學業至上學校，因此在招募工作人員或是，招生都十分困難，畢竟讀書會的時間互相衝突，學生們大多寧可去其他讀書會，可以使學業成績更好，都是資訊跟學科幾乎是沒關係的，因此需要把握一開始的幾節課，使學生們知道<strong>學資訊可以獲得什麼好處</strong>，否則大多數的學員會在一開始的幾節語法課感到無聊，便在一開始的幾節課退出。</p><h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p>我們這屆有三個講師，大概花了一年的時間講到遞迴，枚舉以及二分，使5-10位學員成功在24-01-07的APCS測驗中獲得了實作3的成績，我覺得這還是挺不錯的因為其實一周不過2.5小時，而且有些學員也有其他職位例如糾察，或是遲到等原因，其實一整年的學習時間也不過50-75小時而已。</p>]]></content>
    
    
    <categories>
      
      <category>高中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
      <tag>教學</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOI2024A題解</title>
    <link href="/TOI2024A/"/>
    <url>/TOI2024A/</url>
    
    <content type="html"><![CDATA[<h1 id="題目連結"><a href="#題目連結" class="headerlink" title="題目連結"></a><a href="https://judge.cchs.chc.edu.tw/ShowProblem?problemid=a562">題目連結</a></h1><p>根據題意我們需要找到每個數字經過操作後第一個重複出現的數字。<br>因此使用map來記錄(可能有更好的方法)，剩下的便是實作。<br>實作的過程便是先記錄目前數字的每一項，然後排序之後回傳大-小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-type">int</span> q, n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        a[i]=x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> u=<span class="hljs-number">0</span>, v=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        u*=<span class="hljs-number">10</span>, v*=<span class="hljs-number">10</span>, u+=a[i], v+=a[n-i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> v-u;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    cin&gt;&gt;m;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; chk;<br>    chk[m]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        m=<span class="hljs-built_in">f</span>(m);<br>        <span class="hljs-keyword">if</span>(chk[m]) &#123;cout&lt;&lt;m&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-keyword">else</span> chk[m]=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;q&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(q--) <span class="hljs-built_in">solve</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>題解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>題解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>約瑟夫問題</title>
    <link href="/%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8CO(N)/"/>
    <url>/%E7%B4%84%E7%91%9F%E5%A4%AB%E5%95%8F%E9%A1%8CO(N)/</url>
    
    <content type="html"><![CDATA[<h1 id="題目連結"><a href="#題目連結" class="headerlink" title="題目連結"></a><a href="https://judge.cchs.chc.edu.tw/ShowProblem?problemid=a561">題目連結</a></h1><h2 id="子任務1"><a href="#子任務1" class="headerlink" title="子任務1"></a>子任務1</h2><ul><li>要如何決定每次要刪掉的是誰?<br>暴力實作<br>每次都O(N)移動到下一個需要被踢出的人身上，再使用O(N)的方法將這個人踢出，總共需要 N 次，因此時間複雜度是 O(N^2)。<br>&#x2F;&#x2F;其實子任務1出爛了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) v[i]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-type">int</span> l=v.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;k;j++) &#123;<br>            now++;<br>            now%=l;<br>        &#125;<br>        v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>()+now);<br>    &#125;<br>    cout&lt;&lt;v[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-comment">// 其實這個也可以過子任務二</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="子任務二"><a href="#子任務二" class="headerlink" title="子任務二"></a>子任務二</h2><p>跟句子任務1的程式我們可以發現</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;k;j++) &#123;<br>            now++;<br>            now%=l;<br>&#125;<br></code></pre></td></tr></table></figure><p>其實就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">now=(now+k<span class="hljs-number">-1</span>)%l;<br></code></pre></td></tr></table></figure><p>因此我們可以把這邊簡化成O(1)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) v[i]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-type">int</span> l=v.<span class="hljs-built_in">size</span>();<br>        now=(now+k<span class="hljs-number">-1</span>)%l;<br>        v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>()+now);<br>    &#125;<br>    cout&lt;&lt;v[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子任務三"><a href="#子任務三" class="headerlink" title="子任務三"></a>子任務三</h2><p>由於子任務一二的提示，我們可以發現無論k是多少其實不影響時間複雜度，以及一定要做n-1次操作，所以剩下的優化便只剩下把人踢出這個過程，透過平板電視，可以把這個優化到O(logn)。</p><blockquote><p>其實也可以Treap。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/extc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> flightzz ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);</span><br><span class="hljs-keyword">typedef</span> tree&lt;<span class="hljs-type">int</span>,null_type,less&lt;<span class="hljs-type">int</span>&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;ordered_set;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    ordered_set x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        x.<span class="hljs-built_in">insert</span>(i);<br>    &#125;<br>    <span class="hljs-type">int</span> key=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        key=(key+k<span class="hljs-number">-1</span>)%x.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> it=x.<span class="hljs-built_in">find_by_order</span>(key);<br>        <br>        <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>) cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        x.<span class="hljs-built_in">erase</span>(it);<br>    &#125;<br>&#125;       <br></code></pre></td></tr></table></figure><h2 id="子任務四"><a href="#子任務四" class="headerlink" title="子任務四"></a>子任務四</h2><p>由於N很大，時間複雜度不是O(N)就是O(1)。<br>詳細請見 : <a href="https://hackmd.io/@erichung0906/H1ljCesy">https://hackmd.io/@erichung0906/H1ljCesy</a>_</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/extc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __gnu_pbds;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> flightzz ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);</span><br><span class="hljs-keyword">typedef</span> tree&lt;<span class="hljs-type">int</span>,null_type,less&lt;<span class="hljs-type">int</span>&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;ordered_set;<br><span class="hljs-type">int</span> n, k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;<br>        ret=(ret+k)%i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-comment">// ordered_set x;</span><br>    <span class="hljs-comment">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class="hljs-comment">//     x.insert(i);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// int key=0;</span><br>    <span class="hljs-comment">// for(int i=0;i&lt;n;i++) &#123;</span><br>    <span class="hljs-comment">//     key=(key+k-1)%x.size();</span><br>    <span class="hljs-comment">//     auto it=x.find_by_order(key);</span><br>        <br>    <span class="hljs-comment">//     if(i==n-1) cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br>    <span class="hljs-comment">//     x.erase(it);</span><br>    <span class="hljs-comment">// &#125;</span><br>    cout&lt;&lt;<span class="hljs-built_in">ans</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>題解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>題解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YTP心得</title>
    <link href="/YTP/"/>
    <url>/YTP/</url>
    
    <content type="html"><![CDATA[<p>高一升高二的時候，我和kzzz以比決賽線高3分成功打進<a href="https://www.tw-ytp.org/">YTP</a>的決賽，這次的決賽剛好在IONC後面，原本就有想到會被電得很慘，經過IONC的學習，原本以為可以好一點，但還是只有做出<code>HELLO_WORLD</code>，我跟他以為第一題很好做就卡了很久，最後發現有一個特判的條件沒判到，後面的題目也都偏難，超過了當時我們所學的範圍，希望明年可以至少進前20。</p>]]></content>
    
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高一心得</title>
    <link href="/%E9%AB%98%E4%B8%80%E4%B8%8A%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/"/>
    <url>/%E9%AB%98%E4%B8%80%E4%B8%8A%E5%AD%B8%E7%BF%92%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我覺得主要可以分為<strong>高一上下</strong>和<strong>寒暑假</strong>這<strong>四</strong>個階段，在這四個階段都獲得了許多心態和質量上的提升，下文會將我認為比較有記憶點的東西寫下並記錄自己的<strong>CODING_HOUR</strong>以及一些我認為重要的學習歷程</p><h2 id="主文"><a href="#主文" class="headerlink" title="主文"></a>主文</h2><p>高一上剛接觸資訊圈，覺得有許多可以探索的東西，夢想很美好，覺得甚麼都很好上手，資安專案競程，到頭來一事無成，高一上的我實力不夠再加上參賽的資訊不太夠，在<strong>無緣</strong>初選和NPSC還有學科能競的情況下，高一上就這樣過去了 <strong>(CODING_HOUR:100-200?)</strong></p><p>高一的寒假對我而言算是一個很大的轉捩點，參加了南九校寒訓，認識了很多人也對於資訊有更深層的認識，為期三天的營隊我雖然沒有住宿 **(大遺憾)**，但我卻覺得我成長了許多</p><p>高一下就努力了不少，當上了校內資訊研究社的<strong>講師</strong>:<a href="https://hackmd.io/@FliGhtzzsz">上課內容</a>，也開始做一些<a href="https://github.com/FliGhtzzz">小專案(像是這個)&amp;DCbot之類的</a>，也因為這些經驗讓我學到一些除了競程以外的知識，像是Python，md，LATEX等等，累積了不少我覺得蠻重要的經驗 <strong>(CODING_HOUR:400-500?)</strong></p><p>高一的暑假，我報名了許多營隊，想要將自己的競程再進步，也提升自己的專案製作能力，像是交大的資培營和<a href="https://sitcon.camp/2024/">SITCON_CAMP</a>，在營隊中分別有學到AI深度學習以及<a href="https://github.com/FliGhtzzz/sitconcamp">SITCON_CAMP小組一起做的TG_BOT</a>和開源的精神，比較可惜的是在<strong>學科能競校內的初選</strong>被打爆，開始發現自己寫程式有時候會留一堆坑給自己，也在暑假努力的填坑 <strong>(CODING_HOUR:500-700?)</strong></p>]]></content>
    
    
    <categories>
      
      <category>高中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得</tag>
      
      <tag>學習</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美食地圖</title>
    <link href="/%E7%BE%8E%E9%A3%9F%E5%9C%B0%E5%9C%96/"/>
    <url>/%E7%BE%8E%E9%A3%9F%E5%9C%B0%E5%9C%96/</url>
    
    <content type="html"><![CDATA[<ul><li>這只是我的主觀感受,會避免任何攻擊性的言論 <strong>&lt;3</strong><blockquote><p>開始更新:2024&#x2F;4&#x2F;30<br>最後更新:2024&#x2F;9&#x2F;28</p></blockquote></li></ul><h2 id="彰化"><a href="#彰化" class="headerlink" title="彰化"></a>彰化</h2><h3 id="日式"><a href="#日式" class="headerlink" title="日式"></a>日式</h3><p><a href="https://www.google.com/maps/place/%E5%B9%B8%E8%8A%B1%E9%B7%84%E7%99%BD%E6%B9%AF%E6%8B%89%E9%BA%B5+(%E5%93%A1%E6%9E%97%E4%B8%AD%E6%AD%A3%E5%BA%97)/@23.9575479,120.5725797,19.5z/data=!4m6!3m5!1s0x3469374d6ca32427:0x346f78e5bcf7a56d!8m2!3d23.9577052!4d120.5728179!16s%2Fg%2F11qh328xch?authuser=0&entry=ttu">幸花鷄白湯拉麵 (員林中正店)</a> 湯頭濃郁,價格實惠,但加麵的湯有點少</p><p><a href="https://www.google.com.tw/maps/place/%E6%BB%9D%E7%A6%BE%E8%A3%BD%E9%BA%B5%E6%89%80-%E5%93%A1%E6%9E%97%E6%9E%97%E6%A3%AE%E5%BA%97/@23.9595824,120.5746089,17z/data=!3m1!4b1!4m6!3m5!1s0x346937cbb7acd6ab:0x274ce916d1518dec!8m2!3d23.9595824!4d120.5771838!16s%2Fg%2F11lcvt91q_?hl=zh-TW&entry=ttu&g_ep=EgoyMDI0MDkyNS4wIKXMDSoASAFQAw==">滝禾製麵所 (員林林森店)</a> 柚香的湯頭很棒, 價格一般,肋眼叉燒有戳到我</p><p><a href="https://www.google.com.tw/maps/place/%E5%B0%8F%E7%86%8A%E8%8F%93%E5%AD%90%E5%93%A1%E6%9E%97%E5%BA%97/@23.9600415,120.577261,15z/data=!4m17!1m10!3m9!1s0x346936f77342a283:0xa14f78a5d9aee4b5!2z5bCP54aK6I-T5a2Q5ZOh5p6X5bqX!8m2!3d23.9600221!4d120.5771402!10e5!14m1!1BCgIgAQ!16s%2Fg%2F1q2wd032r!3m5!1s0x346936f77342a283:0xa14f78a5d9aee4b5!8m2!3d23.9600221!4d120.5771402!16s%2Fg%2F1q2wd032r?hl=zh-TW&entry=ttu&g_ep=EgoyMDI0MDkyNS4wIKXMDSoASAFQAw==">小熊菓子員林店</a> 這是一間麵包店,但我覺得它值得出現在這份名單上,麵包很好吃,爆將乳酪大蒜麵包真的超級頂,大推</p>]]></content>
    
    
    
    <tags>
      
      <tag>心得</tag>
      
      <tag>美食</tag>
      
      <tag>動態更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10th-成大邀請賽心得</title>
    <link href="/2024%E6%88%90%E5%A4%A7%E8%B3%BD%E5%BF%83%E5%BE%97/"/>
    <url>/2024%E6%88%90%E5%A4%A7%E8%B3%BD%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://hspc.csie.ncku.edu.tw/">競賽網址</a></li></ul><p>先說結果吧,本次止步於初賽,自己的實力嚴重不足,三個小時的時間才寫了50&#x2F;900分左右,拖累了隊友,第一次參加大型的線上賽,沒有提前講好任何的題目分配或分享過隊員們更適合那些題目</p><p>本次比賽對我而言可能更像是獲得一個<strong>經驗</strong>,這次比賽也讓我知道了<strong>團隊的重要性</strong>,像是我們這隊就在賽後發現有些題目有人會但因為題目的分配所以沒有看到或解答出來</p>]]></content>
    
    
    <categories>
      
      <category>高中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南九校-資得其樂寒訓</title>
    <link href="/%E5%8D%97%E4%B9%9D%E6%A0%A1-%E8%B3%87%E5%BE%97%E5%85%B6%E6%A8%82%E5%AF%92%E8%A8%93/"/>
    <url>/%E5%8D%97%E4%B9%9D%E6%A0%A1-%E8%B3%87%E5%BE%97%E5%85%B6%E6%A8%82%E5%AF%92%E8%A8%93/</url>
    
    <content type="html"><![CDATA[<p>這次寒訓在成大&amp;南一中上課，讓我認識了這個大校園與許許多多的人及電神們.其中我覺得上課的內容非常不錯，從我會的一直到我不會的，而在那麼頂的課程下，行政組也分配了許多活動，帶給我美好的回憶.</p><p>我印象最深的是<strong>贊助商分享</strong>，原以為會是如分享產品或邀請入值等等枯燥乏味的內容，但卻是分享自身經歷或是一些與資訊相關的網站或活動，也讓我可以提前了解一個合格的程式設計師或資安人員在業界所需的能力及工作內容.</p><p>明年我有機會的話還是會想選擇參加，希望這篇心得能幫助有需要的人認識這個營隊.</p><h2 id="上課內容"><a href="#上課內容" class="headerlink" title="上課內容"></a>上課內容</h2><p>因為我是演算組的所以只介紹演算組的(有分為演算組與資安組)</p><h3 id="演算組"><a href="#演算組" class="headerlink" title="演算組"></a>演算組</h3><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">Dynamic programming</a></li><li><a href="https://cplusplus.com/reference/algorithm/sort/">Sort</a></li><li><a href="https://www.geeksforgeeks.org/searching-algorithms/">Searching</a></li><li><a href="https://cplusplus.com/reference/stl/">STL</a></li><li><a href="https://en.wikipedia.org/wiki/Greedy_algorithm">Greedy</a></li></ul><p>PS:未按照上課順序&amp;有提供題目讓我們練習但不方便提供</p><h2 id="Time-line"><a href="#Time-line" class="headerlink" title="Time-line"></a>Time-line</h2><ul><li><p><strong>DAY1</strong> : 9AM-21.30</p></li><li><p><strong>DAY2</strong> : 9AM-21.30</p></li><li><p><strong>DAY3</strong> : 9AM-17.</p></li></ul><p> Total learning hr : <em>12.5&#x2F;33</em><br> Date : <em>2024&#x2F;2&#x2F;5</em> - <em>2024&#x2F;2&#x2F;7</em></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="其他活動"><a href="#其他活動" class="headerlink" title="其他活動"></a>其他活動</h3><ul><li>破冰</li><li>晚會</li><li>經驗分享</li><li>贊助商分享</li><li>實境闖關</li></ul><h3 id="住宿地點"><a href="#住宿地點" class="headerlink" title="住宿地點"></a>住宿地點</h3><p>旅社名稱：老曼船長青年旅舍<br>地址：701台南市東區北門路二段2號（大門在火車站出口的全家裡面）<br>旅社官網連結：<a href="https://oldmancaptain.github.io/">https://oldmancaptain.github.io/</a></p><h3 id="分享電神"><a href="#分享電神" class="headerlink" title="分享電神"></a>分享電神</h3><ul><li><a href="https://koyingtw.github.io/about/"><strong>koying</strong></a></li><li><a href="https://hackmd.io/@L39Ai4MITOCY2Aioz54q2g/colten"><strong>Colten</strong></a></li></ul>]]></content>
    
    
    <categories>
      
      <category>高中</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程式</tag>
      
      <tag>心得</tag>
      
      <tag>營隊</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
